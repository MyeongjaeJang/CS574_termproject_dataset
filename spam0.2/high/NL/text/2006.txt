Abstract Background Haplotype assembly is the task of reconstructing haplotypes of an individual from a mixture of sequenced chromosome fragments. Haplotype information enables studies of the effects of genetic variations on an organism’s phenotype. Most of the mathematical formulations of haplotype assembly are known to be NP-hard and haplotype assembly becomes even more challenging as the sequencing technology advances and the length of the paired-end reads and inserts increases. Assembly of haplotypes polyploid organisms is considerably more difficult than in the case of diploids. Hence, scalable and accurate schemes with provable performance are desired for haplotype assembly of both diploid and polyploid organisms. Results We propose a framework that formulates haplotype assembly from sequencing data as a sparse tensor decomposition. We cast the problem as that of decomposing a tensor having special structural constraints and missing a large fraction of its entries into a product of two factors, U and \(\underline {\mathbf {V}}\) ; tensor \(\underline {\mathbf {V}}\) reveals haplotype information while U is a sparse matrix encoding the origin of erroneous sequencing reads. An algorithm, AltHap, which reconstructs haplotypes of either diploid or polyploid organisms by iteratively solving this decomposition problem is proposed. The performance and convergence properties of AltHap are theoretically analyzed and, in doing so, guarantees on the achievable minimum error correction scores and correct phasing rate are established. The developed framework is applicable to diploid, biallelic and polyallelic polyploid species. The code for AltHap is freely available from https://github.com/realabolfazl/AltHap . Conclusion AltHap was tested in a number of different scenarios and was shown to compare favorably to state-of-the-art methods in applications to haplotype assembly of diploids, and significantly outperforms existing techniques when applied to haplotype assembly of polyploids. Keywords Haplotype assembly Tensor decomposition Iterative algorithm Background Fast and accurate DNA sequencing has enabled unprecedented studies of genetic variations and their effect on human health and medical treatments. Complete information about variations in an individual’s genome is given by haplotypes, the ordered lists of single nucleotide polymorphisms (SNPs) on the individual’s chromosomes [ 1 ]. Haplotype information is of fundamental importance for a wide range of applications. For instance, when the corresponding genes on a homologous pair of chromosomes contain multiple variants, they could exhibit different gene expression patterns. In humans, this may affect an individual’s susceptibility to diseases and response to therapeutic drugs, and hence suggest directions for medical and pharmaceutical research [ 2 ]. Haplotype information also enables whole genome association studies that focus on the so-called tag SNPs [ 3 ], representative SNPs in a region of the genome characterized by strong correlation between alleles (i.e., by high linkage disequilibrium). Moreover, haplotype sequences can be used to infer recombination patterns and identify genes under positive selection [ 4 ]. In addition to the SNPs and minor structural variations found in a healthy individual’s genome, complex chromosomal aberrations such as translocations and nonreciprocal structural changes – including aneuploidy – are present in cancer cells. Cancer haplotype assembly enables identification of “driver” mutations and thus helps to understanding the mechanisms behind the disease and discovery of its genetic signatures. Haplotype assembly from short reads obtained by high-through-put DNA sequencing requires partitioning (either directly or indirectly) the reads into K clusters ( K =2 for diploids, K =3 for triploids, etc.), each collecting the reads corresponding to one of the chromosomes. If the reads were free of sequencing errors, this task would be straightforward. However, sequencing is erroneous – state-of-the-art platforms have error rates on the order of 10 −3 −10 −2 . This leads to ambiguities regarding the origin of a read and therefore renders haplotype assembly challenging. For this reason, the vast majority of haplotype assembly techniques attempts to remove the aforementioned ambiguities by either discarding or altering sequencing data; this has led to the minimum fragment removal, minimum SNP removal [ 5 ], maximum fragments cut [ 6 ], and minimum error correction formulations of the assembly problem [ 7 ]. Most of the recent haplotype assembly methods (see, e.g., [ 8 – 12 ]) focus on the minimum error correction (MEC) formulation where the goal is to find the smallest number of nucleotides in reads that need to be changed so that any read partitioning ambiguities would be resolved. It has been shown that finding optimal solution to the MEC formulation of the haplotype assembly problem is NP-hard [ 5 , 12 , 13 ]. In [ 14 ], the authors used a branch-and-bound scheme to minimize the MEC objective over the space of reads; to reduce the search space, they relied on a bound on the objective obtained by a random partition of the reads. Unfortunately, exponential growth of the complexity of this scheme makes it computationally infeasible even for moderate haplotype lengths. Integer linear programming techniques have been applied to haplotype assembly in [ 15 ], but the approach there fails at computationally difficult instances of the problem. More recently, fixed parameter tractable (FPT) algorithms with runtimes exponential in the number of variants per read [ 16 , 17 ] were proposed; these methods are well-suited for short reads but become infeasible for the long ones. A dynamic programming scheme for haplotype assembly of diploids proposed in [ 18 ] is also exponential in the length of the longest read. A probabilistic dynamic programming algorithm that optimizes a likelihood function generalizing the MEC objective is developed in [ 10 ]; this method is characterized by high accuracy but is significantly slower than the previous heuristics. Authors in [ 9 , 11 ] aim to process long reads by developing algorithms for the exact optimization of weighted variants of the MEC score that scale well with read length but are exponential in the sequencing coverage. These methods, along with ProbHap [ 10 ], struggle to remain accurate and practically feasible at high coverages (e.g., higher than 12 [ 10 ]). The computational challenges of optimizing MEC score has motivated several polynomial time heuristics. In a pioneering work [ 19 ], a greedy algorithm seeking the most likely haplotypes was used to assemble haplotypes of the first complete diploid individual genome obtained via high-throughput sequencing. To compute posterior joint probabilities of consecutive SNPs, Bayesian methods relying on MCMC and Gibbs sampling schemes were proposed in [ 20 ] and [ 21 ], respectively; unfortunately, slow convergence of Markov chains that these schemes rely on limits their practical feasibility. Following an observation that haplotype assembly can be interpreted as a clustering problem, a max-cut formulation was proposed in [ 22 ]; an efficient algorithm (HapCUT, recently upgraded to HapCUT2 [ 23 ]) that solves it and significantly outperforms the method in [ 19 ] was developed and has widely been used. A flow-graph based approach in [ 24 ], HapCompass, re-examined fragment removal strategy and demonstrated superior performance over HapCUT. Other recent diploid haplotype assembly methods include a greedy max-cut approach in [ 25 ], convex optimization program for minimizing the MEC score in [ 26 ], a communication-theoretic interpretation of the problem solved via belief propagation (BP) in [ 27 ], and methods that use external reference panels such as 1000 Genomes to improve accuracy of haplotype assembly in [ 28 , 29 ]. Note that deep sequencing coverage provided by state-of-the-art high-throughput sequencing platforms and the emergence of very long insert sizes in recent technologies (e.g., fosmid [ 25 ]) may enable assembly of extremely long haplotype blocks but also impose significant computational burden on the methods above. Increased affordability, capability to provide deep coverage, and longer sequencing read lengths also enabled studies of genetic variations of polyploid organisms. However, haplotype assembly for polyploid genomes is considerably more challenging than that for diploids; to illustrate this, note that for a polyploid genome with k haplotype sequences of length m , under the all-heterozygous assumption there are ( k −1) m different genotypes and at least 2 ( m −1) ( k −1) m different haplotype phasings. In part for this reason relatively fewer methods for solving the haplotype assembly problems in polyploids have been developed. In fact, with the exception of HapCompass [ 24 ], SDhaP [ 26 ] and BP [ 27 ], the above listed methods are restricted to diploid genomes. Other techniques capable of reconstructing haplotypes for both diploid and polyploid genomes include HapTree [ 30 ], a Bayesian method to find the maximum likelihood haplotype shown to be superior to HapCompass and SDhaP (see, e.g., [ 31 ] for a detailed comparison), H-PoP [ 8 ], the state-of-the-art dynamic programming method that significantly outperforms the schemes developed in [ 24 , 26 , 30 ] in terms of accuracy, memory consumption, and speed, and the recently proposed matrix factorization schemes in [ 32 , 33 ]. In this paper, we propose a unified framework for haplotype assembly of diploid and polyploid genomes based on sparse tensor decomposition; the framework essentially solves a relaxed version of the NP-hard MEC formulation of the haplotype assembly problem. In particular, read fragments are organized in a sparse binary tensor which can be thought of as being obtained by multiplying a matrix that contains information about the origin of erroneous sequencing reads and a tensor that contains haplotype information of an organism. The problem then is recast as that of decomposing a tensor having special structural constraints and missing a large fraction of its entries. Based on a modified gradient descent method and after unfolding the observed and haplotype information bearing tensors, an iterative procedure for finding the decomposition is proposed. The algorithm exploits underlying structural properties of the factors to perform decomposition at a low computational cost. In addition, we analyze the performance and convergence properties of the proposed algorithm and determine bounds on the minimum error correction (MEC) scores and correct phasing rate (CPR) – also referred to as reconstruction rate – that the algorithm achieves for a given sequencing coverage and data error rate. To the best of our knowledge, this is the first polynomial time approximation algorithm for haplotype assembly of diploids and polyploids having explicit theoretical guarantees for its achievable MEC score and CPR. The proposed algorithm, referred to as AltHap, is tested in applications to haplotype assembly for both diploid and polyploid genomes (synthetic and real data) and compared with several state-of-the-art methods. Our extensive experiments reveal that AltHap outperforms the competing techniques in terms of accuracy, running time, or both. It should be noted that while state-of-the-art haplotype assembly methods for polyploids assume haplotypes may only have biallelic sites, AltHap is capable of reconstructing polyallelic haplotypes which are common in many plants and some animals, are of particular importance for applications such as crop cultivation [ 34 ], and may help in reconstruction of viral quasispecies [ 35 ]. Moreover, while many state-of-the-art haplotype assembly methods are computationally intensive (e.g., [ 10 , 15 ]), our extensive numerical experiments demonstrate efficacy of AltHap in a variety of practical settings. Methods Problem formulation We briefly summarize notation used in the paper. Bold capital letters refer to matrices and bold lowercase letters represent vectors. Tensors are denoted by underlined bold capital letters, e.g., \(\underline {\mathbf {M}}\) . M ::1 and \(\overline {\mathbf {M}}\) denote the frontal slice and the mode-1 unfolding of a third-order tensor \(\underline {\mathbf {M}}\) , respectively. For a positive integer n , [ n ] denotes the set {1…, n }. The condition number of rank- k matrix M is defined as κ = σ 1 / σ k where σ 1 ≥ ⋯ ≥ σ k >0 are singular values of M . SVD k ( M ) denotes the rank k approximation (compact SVD) of M computed by power iteration method [ 36 , 37 ]. Let \({\mathcal {H}}=\{\mathbf {h}_{1},\dots,\mathbf {h}_{k}\}\) denote the set of haplotype sequences of a k -ploid organism, and let R be an n × m SNP fragment matrix where n denotes the number of sequencing reads and m is the length of haplotype sequences. R is an incomplete matrix that can be thought of as being obtained by sampling, with errors, matrix M that consists of n rows; each row of M is a sequence randomly selected from among k haplotype sequences. Since each SNP is one of four possible nucleotides, we use the alphabet \({\mathcal {A}}=\{(1,0,0,0),(0,1,0,0),(0,0,1,0),(0,0,0,1)\}\) to describe the information in the haplotype sequences; the mapping between nucleotides and alphabet components follows arbitrary convention. The reads can now be organized into an n × m ×4 SNP fragment tensor which we denote by \(\underline {\mathbf {R}}\) . The ( i , j ,:) fiber of \(\underline {\mathbf {R}}\) , i.e., a one-dimensional slice obtained by fixing the first and second indices of the tensor, represents the value of the j t h SNP in the i t h read. Let Ω denote the set of informative fibers of \(\underline {\mathbf {R}}\) , i.e., the set of ( i , j ,:) such that the i t h read covers the j t h SNP. Define an operator \({\mathcal {P}}_{\Omega }(.)\) as $$ \left[{\mathcal{P}}_{\Omega}(\underline{\mathbf{R}})\right]_{ij:}=\left\{ \begin{array}{ll} \mathbf{R}_{ij:}& (i, j,:) \in \Omega\\ \mathbf{0},& \text{otherwise.} \end{array}\right. $$ (1) \({\mathcal {P}}_{\Omega }(\underline {\mathbf {R}})\) is a tensor obtained by sampling, with errors, tensor \(\underline {\mathbf {M}} \in {\mathcal {A}}^{n \times m}\) having n copies of k encoded haplotype sequences as its horizontal slices. More specifically, we can write \(\underline {\mathbf {M}}=\mathbf {U}\underline {\mathbf {V}}^{\top }\) , where \(\underline {\mathbf {V}} \in {\mathcal {A}}^{m \times k}\) contains haplotype information, i.e., the j t h vertical slice of \(\underline {\mathbf {V}}\) , V : j : , is the encoded sequence of the j t h haplotype, and U ∈ {0,1} n × k is a matrix that assigns each of n horizontal slices of \(\underline {\mathbf {M}}\) to one of k haplotype sequences, i.e., the i t h row of U , u i , is an indicator of the origin of the i t h read. Let Φ ={ e 1 ,…, e k }, where \(\mathbf {e}_{l} \in \mathbb {R}^{k}\) is the l t h standard basis vector having 1 in the l t h position and 0 elsewhere. The rows of U are standard unit basis vectors in \(\mathbb {R}^{k}\) , i.e., u i ∈ Φ , ∀ i ∈ [ n ]. This representation is illustrated in Fig. 1 where the (1,1,:) fiber of \(\underline {\mathbf {V}}\) specified with dashed lines is mapped to the (1,1,:) fiber of \(\underline {\mathbf {M}}\) which in turn implies that in the example described in Fig. 1 we have u 1 = e 1 . Fig. 1 Representing haplotype sequences and sequencing reads using tensors. Tensor \(\underline {\mathbf {V}} \in {\mathcal {A}}^{m \times k}\) contains haplotype information while matrix U ∈ {0,1} n × k assigns each of the n horizontal slices of \(\underline {\mathbf {M}}\) to one of the k haplotype sequences, i.e., the i t h row of U is an indicator of the origin of the i t h read DNA sequencing is erroneous and hence we assume a model where the informative fibers in \(\underline {\mathbf {R}}\) are perturbed versions of the corresponding fibers in \(\underline {\mathbf {M}}\) with data error rate p e , i.e., if the ( i , j ,:) ∈ Ω fiber in \(\underline {\mathbf {M}}\) takes value \(\mathbf {e}_{l} \in {\mathcal {A}}\) , R i j : with probability 1− p e equals e l and with probability p e takes one of the other three possibilities. Thus, the observed SNP fragment tensor can be modeled as \(\underline {\mathbf {R}}={\mathcal {P}}_{\Omega }(\underline {\mathbf {M}}+\underline {\mathbf {N}})\) where \(\underline {\mathbf {N}}\) is an additive noise tensor defined as $$ \mathbf{N}_{ij:}=\left\{ \begin{array}{cc} \mathbf{0}, &\text{ w.p}\quad 1-p_{e} \\ {\mathcal{U}}({\mathcal{A}}\backslash\{\mathbf{M}_{ij:}\})-\mathbf{M}_{ij:},&\text{ w.p}\quad p_{e}, \end{array}\right. $$ (2) where the notation \({\mathcal {U}}({\mathcal {A}}\backslash \{\mathbf {M}_{ij:}\})\) denotes uniform selection of a vector from \({\mathcal {A}}\backslash \{\mathbf {M}_{ij:}\}\) . The goal of haplotype assembly can now be formulated as follows: Given the SNP fragment tensor \(\underline {\mathbf {R}}\) , find the tensor of haplotype sequences \(\underline {\mathbf {V}}\) that minimizes the MEC score . Next, we formalize the MEC score as well as the correct phasing rate, also known as reconstruction rate, the two metrics that are used to characterize performance of haplotype assembly schemes (see, e.g., [ 15 , 18 , 38 , 39 ]). For two alleles a 1 , \(\mathbf {a}_{2} \in {\mathcal {A}}\cup \{\mathbf {0}\}\) , we define a dissimilarity function d ( a 1 , a 2 ) as $$ d(\mathbf{a}_{1},\mathbf{a}_{2})=\left\{ \begin{matrix} 1,& \text{if } \mathbf{a}_{1},\mathbf{a}_{2}\neq \mathbf{0} \text{ and } \mathbf{a}_{1}\neq\mathbf{a}_{2}\\ 0,& \text{otherwise.} \end{matrix}\right. $$ (3) The MEC score is the smallest number of fibers in \(\underline {\mathbf {R}}\) that need to be altered so that the resulting modified data is consistent with the reconstructed haplotype \(\underline {\mathbf {V}}\) , i.e., $$ \text{MEC}=\sum_{i=1}^{n} \min_{p=1,\dots,k} \sum_{j=1}^{m} d(\mathbf{R}_{ij:},\mathbf{V}_{jp:}). $$ (4) The correct phasing rate (CPR), also referred to as the reconstruction rate, can conveniently be written using the dissimilarity function d (.,.). Let \(\underline {\mathbf {V}}^{t}\) denote the tensor of true haplotype sequences. Then $$ \text{CPR}=1-\frac{1}{mk}\left(\min_{\mathcal{M}} \sum_{i=1}^{m}\sum_{j=1}^{k} d\left({\mathcal{M}}(\underline{\mathbf{V}})_{ij:},\mathbf{V}_{ij:}^{t}\right)\right), $$ (5) where \(\mathcal {M}\) is a one-to-one mapping from lateral slices of \(\underline {\mathbf {V}}\) to those of \(\underline {\mathbf {V}}^{t}\) , i.e., a one-to-one mapping from the set of reconstructed haplotypes to the set of true haplotypes. We now describe our proposed relaxation of the MEC formulation of the haplotype assembly problem. Let p i ∈ [ k ], ∀ i ∈ [ n ] be defined as \(p_{i}= \arg \min _{p} \sum _{j=1}^{m} d\left (\mathbf {R}_{ij:},{\mathbf {V}}_{jp:}\right)\) . Notice that for any j such that d ( R i j : , V j p : )=1, \(\|\mathbf {R}_{ij:}-{\mathbf {V}}_{jp:}\|_{2}^{2}=2\) . Therefore, by denoting \(\Omega =\cup _{i=1}^{n}\Omega _{i}\) where Ω i the set of informative fibers for the i t h read we obtain $$ \begin{aligned} p_{i}&= \arg\min_{p} \sum_{j=1}^{m} d\left(\mathbf{R}_{ij:},{\mathbf{V}}_{jp:}\right)\\ & = \frac{1}{2}\arg\min_{p}\sum_{j=1}^{m}\|\mathbf{R}_{ij:}-{\mathcal{P}}_{\Omega_{i}}\left({\mathbf{V}}_{jp:}\right)\|_{2}^{2} \\ &\stackrel{(a)}{=} \frac{1}{2}\arg\min_{p}\|\mathbf{R}_{i::}-{\mathcal{P}}_{\Omega_{i}}\left({\mathbf{V}}_{:p:}\right)\|_{F}^{2}\\ &\stackrel{(b)}{=} \frac{1}{2}\arg\min_{p}\|\text{vec}(\mathbf{R}_{i::})-\text{vec}\left({\mathcal{P}}_{\Omega_{i}}\left({\mathbf{V}}_{:p:}\right)\right)\|_{2}^{2} \end{aligned} $$ (6) where ( a ) follows from the definition of the Frobenius norm and vec(.) in ( b ) denotes the vectorization of its argument. Let e p be the p t h standard unit vector ∀ p ∈ [ k ]. It is straightforward to observe that the last equality in ( 6 ) can equivalently be written as $$p_{i}=\frac{1}{2}\arg\min_{p}\|\text{vec}(\mathbf{R}_{i::})-{\mathcal{P}}_{\Omega_{i}}\left(\overline{\mathbf{V}}\mathbf{e}_{p}\right)^{\top}\|_{2}^{2} $$ where \(\overline {\mathbf {V}}\) is the mode-1 unfolding of the tensor \(\underline {\mathbf {V}}\) . Hence, $$\text{MEC}=\frac{1}{2}\sum_{i=1}^{n} \|\text{vec}(\mathbf{R}_{i::})-{\mathcal{P}}_{\Omega_{i}}\left(\overline{\mathbf{V}}\mathbf{e}_{p}\right)^{\top}\|_{2}^{2}. $$ Let U ∈ {0,1} n × k be the matrix such that for its i t h row it holds that \(\mathbf {u}_{i} = \mathbf {e}_{p_{i}}\phantom {\dot {i}\!}\) . In addition, notice that vec( R i :: ) is the i t h row of \(\overline {\mathbf {R}}\) . Therefore, from the definition of the Frobenius norm and the fact that \({\mathcal {P}}_{\Omega }(\overline {\mathbf {R}})=\overline {\mathbf {R}}\) we obtain $$ \text{MEC}=\min_{\mathbf{U},\overline{\mathbf{V}}}\frac{1}{2}\left\|{\mathcal{P}}_{\Omega}\left(\overline{\mathbf{R}}-\mathbf{U}\overline{\mathbf{V}}^{\top}\right)\right\|_{F}^{2}. $$ (7) The optimization problem in ( 7 ) is NP-hard since the entries of \(\overline {\mathbf {V}}\) are binary and the objective function is non-convex. Relaxing the binary constraint to \(\overline {\mathbf {V}}_{i,j} \in {\mathcal {C}}\) , ∀ i ∈ [4 m ], ∀ j ∈ [ k ], where \({\mathcal {C}}=[0,1]\) , results in the following relaxation of the MEC formulation, $$ \begin{aligned} & \underset{\mathbf{U},\overline{\mathbf{V}}}{\text{min}} \quad \frac{1}{2}\left\|{\mathcal{P}}_{\Omega}\left(\overline{\mathbf{R}}-\mathbf{U}\overline{\mathbf{V}}^{\top}\right)\right\|^{2}_{F}\\ & \text{s.t.}\hspace{0.5cm}\overline{\mathbf{V}}_{i,j} \in {\mathcal{C}}, \forall i \in [4m], \forall j \in [k]\\ &\hspace{0.85cm} \mathbf{u}_{i} \in \Phi, \forall i \in [n]. \end{aligned} $$ (8) The new formulation can be summarized as follows. We start by finding the so-called mode-1 unfolding of tensors \(\underline {\mathbf {M}}\) and \(\underline {\mathbf {V}}\) and denote the decomposition \(\overline {\mathbf {M}}=\mathbf {U}\overline {\mathbf {V}}^{\top }\) , as illustrated in Fig. 2 . As implied by the figure, after unfolding, the entries of the (1,1,:) fiber are mapped to four blocks of \(\overline {\mathbf {M}}\) and \(\overline {\mathbf {V}}\) that correspond to the frontal slices of tensors \(\underline {\mathbf {M}}\) and \(\underline {\mathbf {V}}\) , respectively. Then, to determine the haplotype sequence that minimizes the MEC score, one needs to solve ( 8 ) and find the optimal tensor decomposition. Fig. 2 Representing haplotype sequences and sequencing reads using unfolded tensors. Matrix \(\overline {\mathbf {V}} \in \{0,1\}^{4m \times k}\) contains haplotype information while matrix U ∈ {0,1} n × k assigns each of the n rows of \(\overline {\mathbf {M}}\) to one of the k haplotype sequences, i.e., the i t h row of U is an indicator of the origin of the i t h read The AltHap algorithm Although the objective function in ( 8 ), i.e., $${{f(\mathbf{U},\overline{\mathbf{V}})=\frac{1}{2}\|{{\mathcal{P}}_{\Omega}}\left(\overline{\mathbf{R}}-\mathbf{U}\overline{\mathbf{V}}^{\top}\right)\|^{2}_{F}}} $$ is convex in each of the factors when the other factor is fixed, \(f(\mathbf {U},\overline {\mathbf {V}})\) is generally nonconvex. To facilitate computationally efficient search for the solution of ( 8 ), we rely on a modified gradient search algorithm which exploits the special structures of U and \(\overline {\mathbf {V}}\) and iteratively updates the estimates \((\mathbf {U}_{t},\overline {\mathbf {V}}_{t})\) starting from some initial point \((\mathbf {U}_{0} \overline {\mathbf {V}}_{0})\) . More specifically, given the current estimates \((\mathbf {U}_{t},\overline {\mathbf {V}}_{t})\) , the update rules are $$ \mathbf{U}_{t+1}=\arg\min_{\mathbf{u}_{i} \in \Phi}{\sum_{(i,j)\in \Omega}\left\|{\mathcal{P}}_{\Omega}\left(\overline{\mathbf{R}}-\mathbf{U}_{t}\overline{\mathbf{V}}_{t}^{\top}\right)\right\|_{F}^{2}} $$ (9) $$ \overline{\mathbf{V}}_{t+1}={{\Pi_{\mathcal{C}}}}\left(\overline{\mathbf{V}}_{t}-\alpha{{\nabla f}}(\overline{\mathbf{V}}_{t})\right), $$ (10) where \({{\nabla f}} \left (\overline {\mathbf {V}}_{t}\right) = -\left ({\mathcal {P}}_{\Omega }\left (\overline {\mathbf {R}}-\mathbf {U}_{t+1}\overline {\mathbf {V}}_{t}^{\top }\right)\right)^{\top }\mathbf {U}_{t+1}\) denotes the partial derivative of \(f\left (\mathbf {U},\overline {\mathbf {V}}\right)\) evaluated at \(\left (\mathbf {U}_{t+1},\overline {\mathbf {V}}_{t}\right)\) , α is a judiciously chosen step size, and \({{\Pi _{\mathcal {C}}}}\) denotes the projection operator onto \({\mathcal {C}}\) . Notice that the optimization in ( 9 ) is done by exhaustively searching over k vectors in Φ . Since the number of haplotypes k is relatively small, the complexity of the exhaustive search ( 9 ) is low. The proposed scheme is formalized as Algorithm 1. Note that AltHap differs from a previously proposed SCGD algorithm in [ 32 ] as follows: (i) AltHap’s novel representation of haplotypes and sequencing reads using binary tensors provides a unified framework for haplotype assembly of diploids as well as biallelic and polyallelic polyploids. The method in [ 32 ] is not capable of performing haplotype assembly of polyallelic polyploid genomes. (ii) Unlike [ 32 ], AltHap exploits the fact that \(\underline {\mathbf {V}}\) is composed of binary entries by imposing the constraint \(\overline {\mathbf {V}}_{i,j} \in {\mathcal {C}}\) in the MEC relaxation in ( 8 ). As our results in Section 5 demonstrate, this leads to significant performance improvements of AltHap over SCGD in a variety of settings. (iii) Lastly, in Section 4 we provide analysis of the global convergence of AltHap and derive explicit analytical bounds on its achievable performance. Such performance guarantees do not exist for the method in [ 32 ]. Convergence analysis of AltHap In this section, we analyze the convergence properties of AltHap and provide performance guarantees in different scenarios. In the Additional file 1 we show that, a judicious choice of the step size α according to $$ \alpha=\frac{C\|{{\nabla f}}\left(\overline{\mathbf{V}}_{t}\right)\|_{F}^{2}}{\left\|{\mathcal{P}}_{\Omega}\left(\mathbf{U}_{t+1}{{\nabla f}}\left(\overline{\mathbf{V}}_{t}\right)^{\top}\right)\right\|_{F}^{2}}, $$ (11) where C ∈ (0,2) is a constant, guarantees that the value of the objective function in ( 8 ) decreases as one alternates between ( 9 ) and ( 10 ), which in turn implies that AltHap converges. The key observation that leads to this result is that \(f(\mathbf {U},\overline {\mathbf {V}})\) is a convex function in each of the factor matrices and that \({\mathcal {C}}=[0,1]\) is a convex set; hence the projection \({{\Pi _{\mathcal {C}}}}\) in ( 10 ) leads to a reduction of \(f\left (\mathbf {U}_{t},\overline {\mathbf {V}}_{t}\right)\) in each iteration t . It is important however to determine the conditions under which the stationary point of AltHap coincides with the global optima of ( 8 ). To this end, we first provide the definition of incoherence of matrices [ 40 ]. Definition 1 A rank-k matrix \(\mathbf {M} \in \mathbb {R}^{n \times m}\) with singular value decomposition \(\mathbf {M}=\hat {\mathbf {U}}\mathbf {\Sigma }\hat {\mathbf {V}}^{\top }\) is incoherent with parameter \(1\leq \mu \leq \frac {\max \{n,m\}}{k}\) if for every 1≤ i ≤ n , 1≤ j ≤ m $$ \sum_{l=1}^{k}{\hat{\mathbf{U}}_{il}^{2}\leq \frac{\mu k}{n}},\quad \sum_{l=1}^{k}{\hat{\mathbf{V}}_{jl}^{2}\leq \frac{\mu k}{m}}. $$ (12) Let each fiber in M T be observed uniformly with probably p . Let C snp = △ m p denote the expected number of SNPs covered by each read, and C seq = △ n p denote the expected coverage for each of the haplotype sequences. Theorem 1 built upon the results of [ 41 – 43 ] states that with an adequate number of covered SNPs, the solution found by AltHap reconstructs \(\overline {\mathbf {M}}\) up to an error term that stems from the existence of errors in sequencing reads. Theorem 1 Assume \(\overline {\mathbf {M}}\) is μ -incoherent. Suppose the condition number of \(\overline {\mathbf {M}}\) is κ . Then there exist numerical constants C 0 , C 1 >0 such that if Ω is uniformly generated at random and $$ C_{\text{snp}} > \max\left\{ C_{0} \sqrt[3]{\mu^{4}k^{14}\kappa^{12} C_{\text{seq}}},\frac{p_{e} k^{2} \kappa^{6}}{2C_{1}}\right\} $$ (13) with probability at least \(1-\frac {1}{m^{3}}\) , the solution \((\mathbf {U}^{*}, \overline {\mathbf {V}}^{*})\) found by AltHap satisfies $$ \left\|\overline{\mathbf{M}}-\mathbf{U}^{*}{\overline{\mathbf{V}}^{*}}^{\top}\right\|_{F}^{2} \leq \frac{C_{1} \kappa^{4} p_{e} k m}{2C_{\text{snp}}}. $$ (14) The proof of Theorem 1 relies on a coupled perturbation analysis to establish a certain type of local convexity of the objective function around the global optima. Thus, under ( 13 ) there is no other stationary point around the global optima and hence, starting from a good initial point, AltHap converges globally. We employ the initialization procedure suggested by [ 42 ] – summarized in the initialization step of Algorithm 1 – which is based on a low cost singular value decomposition of \(\overline {\mathbf {R}}\) using power method [ 36 , 37 ] and with high probability lies in the described convexity region of \(f(\mathbf {U},\overline {\mathbf {V}})\) . Remark 1 Under the assumption of 1, the Condition \(C_{\text {snp}} > C_{0} \sqrt [3]{\mu ^{4}k^{14}\kappa ^{12} C_{\text {seq}}}\) specifies a lower bound on the expected number of covered SNPs, C snp , that is required for the exact recovery of \(\overline {\mathbf {M}}\) in the idealistic error-free scenario, i.e., for p e =0. With higher sequencing coverage, more SNPs are covered by the reads and hence C snp required for accurate haplotype assembly scales with C seq along with other parameters. Moreover, the term \(\frac {C_{1} \kappa ^{4} p_{e} k m}{2C_{\text {snp}}}\) on the right hand side of ( 14 ) is the bound on the error of the solution generated by AltHap which increases with the sequencing error rate p e and ploidy k , and decreases with C snp and the number of reads n , as expected. Remark 2 If \(\overline {\mathbf {M}}\) is well-conditioned, i.e., \(\overline {\mathbf {M}}\) is characterized by a small incoherence parameter μ and a small condition number κ , the recovery becomes easier; this is reflected in less strict sufficient condition ( 13 ) and improved achievable performance ( 14 ). In fact, as we verified in our simulation studies, by using the proposed framework for haplotype assembly, the parameters μ and κ associated with \(\overline {\mathbf {M}}\) are close to 1 (the ideal case). Theorem 2 provides theoretical bounds on the expected MEC scores and CPR achieved by AltHap. (See Additional file 1 for the proof). Theorem 2 Under the conditions of Theorem 1, with probability at least \(1-\frac {1}{m^{3}}\) it holds that $$ \mathbb{E}\{\text{MEC}\} \leq 2 p_{e} \left(C_{\text{seq}}m+\kappa^{4}C_{1}k\right). $$ (15) Moreover, if the reads sample haplotype sequences uniformly, with probability at least \(1-\frac {1}{m^{3}}\) it holds that $$ \mathbb{E}\{\text{CPR}\} \geq 1-\frac{C_{1} \kappa^{4} p_{e} k}{nC_{\text{snp}}}. $$ (16) Remark 3 The bound established in ( 15 ) suggests that the expected MEC increases with the length of the haplotype sequences, sequencing error, number of haplotype sequences, and sequencing coverage. A higher sequencing coverage results in a larger fragment data which in turn leads to higher MEC scores. Remark 4 As intuitively expected, the bound ( 16 ) suggests that AltHap’s achievable expected CPR improves with the number of sequencing reads and the SNP coverage; on the other hand, the CPR deteriorates at higher data error rates. Finally, assuming the same sequencing parameters, ( 16 ) implies that reconstruction of polyploid haplotypes is more challenging than that of diploids. Results and discussion We evaluated the performance of the proposed method on both experimental and simulated data, as described next. AltHap was implemented in Python and MATLAB, and the simulations were conducted on a single core Intel Xeon E5-2690 v3 (Haswell) with 2.6 GHz and 64 GB DDR4-2133 RAM. The benchmarking algorithms include Belief Propagation (BP) [ 27 ], a communication-inspired method capable of performing haplotype assembly of diploid and biallelic polyploid species, HapTree [ 30 ], integer linear programming (ILP) technique [ 15 ], SCGD [ 32 ], and H-PoP [ 8 ], the state-of-the-art dynamic programming algorithm for haplotype assembly of diploid and biallelic polyploid species shown to be superior to HapTree [ 30 ], HapCompass [ 24 ], and SDhaP [ 26 ] in terms of both accuracy and speed [ 8 , 31 ]. Following the prior works on haplotype assembly (see, e.g., [ 15 , 18 , 38 , 39 ]) we use MEC score and CPR to assess the quality of the reconstructed haplotypes. For clarity, in the tables we report the CPR percentage, i.e., CPR × 100. Experimental data We first tested performance of AltHap in an application to haplotype reconstruction of a data set from the 1000 Genomes Project – in particular, the sample NA12878 sequenced at high coverage using the 454 sequencing platform. In this work, we take the trio-phased variant calls from the GATK resource bundle [ 44 ] as the true haplotype sequences. We compare the MEC score, CPR, and running time achieved by AltHap to those of H-PoP, BP, HapTree, SCGD and ILP. All the algorithms used in the benchmarking study were executed with their default settings. The results are given in Table 1 . As seen there, among the considered algorithms AltHap achieves the highest CPR for majority of the chromosomes (nine), followed by H-PoP and ILP (five each). As expected, ILP achieves the lowest MEC scores among all the methods but this comes at a computational cost much higher than that of AltHap. Notice that lower MEC score does not necessarily imply better CPR. MEC is the error evaluated on observed SNPs positions, i.e., the training data points, while CPR is related to the generalization error that is calculated on unobserved SNPs positions, i.e., the test data points. Since the sequencing reads are erroneous, an algorithm might over-fit while trying to minimize the MEC score. Table 1 Performance comparison of AltHap, H-PoP, BP, HapTree, SCGD, and ILP applied to haplotype reconstruction of the CEU NA12878 data set in the 1000 Genomes Project